# 第四章 图像和大型数组类型
## 动态可变的存储
cv::Mat类用于表示任意维度的稠密数组，与之相对的是稀疏数组(spare array,只存储非0数值。
如果数组中0很多，稀疏数组会更节约内存。用例: 统计直方图)
## cv::Mat类N维稠密数组
可以看作是按栅格扫描顺序存储的n维数组。在一维数组中，元素是按顺序排列的(从左往右)。在
二维数组中，数据按行组织，每一行按顺序排列 (从左往右，从上往下)。在三维数组中，所有的
通道都被行填充，每一个通道同样按顺序排列。
所有矩阵都包含有: 一个表示它所包含数组类型的元素flag，一个表示其维度的元素dims，表示
行和列数目的元素rows和cols(在dims大于2的时候无效)，一个指示数据真正存储位置的data指
针，一个表示该内存区域有多少引用的refcount元素(类似于cv::Ptr<>的引用计数器)。
data的结构用step[]描述。
cv::Mat中的数据可以是一个数字，也可以是多个数字，后者被称为"多通道数组"。例如，一个
数组被声明为二维三通道32位浮点型数组，那么数组的元素就是大小位12个字节的32位浮点数据
(单精度浮点数使用32位来存储一个浮点数。一个浮点数 32 bit = 4 byte(字节),三通道即12
个字节)
## 创建一个数组

			cv::Mat m;//实例化变量创建数组，没有大小和数据类型
			m.create(3,10,CV_32FC3); //申请内存区域，指定行数和列数以及数据类型来
			//配置二维数组的规模。数据类型包括指明数据的类型和通道数。CV_32FC3表示
			//一个三通道的32位浮点数据。**CV_{8U,16S,16U,32S,32F,64F}C{1,2,3}**
			m.setTo( cv::Scalar(1.0f, 0.0f, 1.0f) );
			等效于 cv::Mat m( 3,10, cv_32FC3, cv::Scalar(1.0f, 0.0f, 1.0f) );
当我们把一个矩阵n赋值给m时(m=n)。之前的m的数据指针指向的数据实体m将会被释放，与此同
时，m和n共享的内存区域的引用指针会增加一个引用计数，然后m与实体相关的成员将依据新数
据警醒更新(比如行数，列数，数据类型等)。
OpenCV允许定义超过3通道的数据类型，需要调用CV_{8U,16S,32S,32F,64F}C(),例如
CV_8UC(7)。而CV_8UC(3)等效于CV_8UC3。
cv::Mat的构造函数:
* 默认构造函数 cv::Mat
* 指定类型的二维数组 
	* cv::Mat( int rows, int cols, int type );
	* cv::Mat( int rows, int cols, int type, const Scalar&s );
	* cv::Mat( int rows, int cols, int type, void* data, size_t step = AUTO_STEP );
* 使用Size对象来构造一个二维数组
	* cv::Mat( cv::Size sz, int type );
	* cv::Mat( cv::Size sz, int type, const Scalar&s );
	* cv::Mat( cv::Size sz, int type, void* data, size_t step = AUTO_STEP );
* 指定类型的多维数组
	* cv::Mat( int ndims, const int* sizes, int type);
	* cv::Mat( int ndims, const int* sizes, int type, const Scalar&s);
	* cv::Mat( int ndims, const int* sizes, int type, void* data, size_t step = AUTO_STEP);
以上构造函数中含有data的直接指定预先存储的数据，该行为不会发生复制而是值创建了一个指向数据的头，而含
有Scalar的直接指定初始化值。
cv::Mat的复制构造函数
	* cv::Mat( const Mat& mat ); 
	* cv::Mat( const Mat& mat, const cv::Range& rows, const cv::Range& cols );
		//从指定的行和列中复制
	* cv::Mat( const Mat& mat, const cv::Rect& roi); //从感兴趣的区域中复制
	* cv::Mat( const Mat& mat, const cv::Range* ranges ); //从n维数组的泛化的感兴趣区域中复制
	* cv::Mat( const cv::MatExpr& expr ); //从其他矩阵的线性代数表述中生成新矩阵的复制构造函数
子区域(ROI)构造函数分为:二维中给定行和列的范围，二维中使用Rect指定举行子区域，输入一个range数组。
range所指向的有效范围的维度必须和mat的维度相等。
cv::Mat(带)模板(的)构造函数
* cv::Mat( const cv::Vec<T,n> & vec, bool copyData=true );// 构造一个如同cv::Vec所指定的数据类型
	为T，大小为n的一维数组
* cv::Mat( const cv::Matx<T,m,n>& vec, bool copyData=true );// 大小 m x n
* cv::Mat( const std::vector<T>& vec, bool copyData=true ); //一维数组
构造cv::Mat的静态方法
* cv::Mat::zeros(rows, cols, type);
* cv::Mat::ones(rows, cols, type);
* cv::Mat::eye(rows, cols, type);
使用cv::Mat::eye()和cv::Mat::ones()的时候，如果是一个多维数组，则**只有第一通道**被设为1，其余通道
保持为0。
## 访问元素
访问一个元素的主要方法是通过**位置**或**迭代器**访问。
直接访问通过at<>()来实现。其工作方式是先将at<>()特化到矩阵所包含的数据类型，然后通过行和列的位置访问。
例如:

				cv::Mat m = cv::Mat::eye( 10, 10, 32FC1 );
				printf( "Element (3,3) is %f\n", m.at<float>(3,3) );
多通道数组:

				cv::Mat m = cv::Mat::eye( 10, 10. 32FC2 );
				printf( "Element (3,3) is (%f,%f)\n", m.at<float>(3,3)[0], m.at<float>(3,3)[1] );
当你相对多维数组指定一个类似于at<>()的模板函数时，最好使用cv::Vec<>对象(预先创建的别名或模板形式)。
例如创建一个复数数组

				cv::Mat m = cv::Mat::eye( 10,10,cv:DataType<cv::Complexf>::type);
				printf("Element (3,3) is %f+i%f\n", m.at<cv::Complexf>(3,3).re, 
				m.at<cv::Complexf>(3,3).im);
这里使用了cv::DataType<>模板。矩阵的构造函数需要一个类型为int的值来作为运行值，这个值页恰好作为某些
"魔法"值可以被构造函数所理解。cv::Complexf是真正的数据对象的类型，实在编译过程中构造的。当我们从编译
时的表示生成一个运行时的表示时就需要cv::DataType<>模板。
at<>()访问器函数的变体:
* M.at<int>(i);//整型数组M中的元素i
* M.at<float>(i,j);//浮点型数组M中的元素(i,j)
* M.at<int>(pt);//整型矩阵M中处于(pt.x, pt.y)的元素
* M.at<float>(i,j,k);//三维浮点型矩阵M中处于(i,j,k)的元素
* M.at<uchar>(idx);//无符号字符数组M中位于idx[]所索引的n维位置的元素

为了访问二维数组，可以使用C风格的指针来指定某一行。可以使用ptr<>()。由于数组中的数据是按行来保存的，
因此不能通过这种方式访问一个指定的列。
由于at<>(),ptr<>()都是模板函数，所以需要一个类型名来实例化。函数接受一个整型参数来指示希望指针指向的
行，函数将返回一个和矩阵原始数据类型相同的数据指针(比如，数据类型是CV_32FC3,将返回一个float*)。因此，
给定一个类型为float的三通道的矩阵mtx，结构体mtx.ptr<Vec3f>(3)将会返回mtx的第三行所指向的第一个元素
第一个浮点通道的指针，这是访问数组最快的一种方式。一旦拥有指针，就可以向指定的位置写入数据。
使用at<>和利用指针访问的差距取决于编译器的优化程度。使用at<>进行存储性能更接近好的优化器所额能达到的
效果。但是如果优化器被关闭了，at<>性能比没有优化器会有一个数量级的提升。通过迭代器访问总比这两种方法
都要慢。然而在所有情况下，内置的OpenCV函数都比你写的所有通过循环来控制直接访问的方法块，所以在任何情
况下，都要**避免通过循环来大量访问矩阵的内部结构**。
### 获取指向矩阵的指针
有两种方式可以获得一个指向矩阵mtx的数据区域的指针。一种是使用ptr<>()成员函数，另一种是直接使用数据指
针data，然后使用成员数组step来计算地址。后者更接近C语言中的操作。一般来说，由于at<>()和ptr<>()以及
迭代器的存在，这种做法已经不推荐了，但计算地址始终是最有效率的做法，尤其是要处理多于二维的数组时。
如果想要访问一个数组中的所有东西，可能需要一次性迭代一行，因为这些行在数组中可能是连续的，但也可能是
不连续的，成员函数isContinuous()将告诉你数组是否被连续的打包。如果是连续的，就可以通过获取第一行的第
一个元素的指针，然后在整个数组中遍历，仿佛它是一个巨大的一维数组。
### 使用迭代器
另一种序列存储方式是使用cv::Mat内嵌的迭代器机制。这种机制是基于STL容器的。基础想法是OpenCV提供一对
迭代器模板，一个用于只读(const)数组的和一个用于非只读(non-const)数组的迭代器cv::MatConstIterator<>
和cv::MatIterator<>。cv::Mat的成员函数begin()和end()会返回这种类型的对象，因为迭代器有足够的智能来
处理连续的内存区域和非连续的内存区域，所以这种用法非常方便，不管在哪一种维度的数组中都非常有效。

所有的迭代器都必须在数组建立的时候声明并指定一个对象类型。

				int sz[3]={4,4,4};
				cv::Mat m(3,sz,CV_32FC3);//4x4x4的三维数组
				cv::randu(m,-1.0f,1.0f);
				float max = 0.0f;
				cv::MatConstIterator<cv::Vec3f> it = m.begin();
				while(it!=m.end())
				{
					len2 = (*it)[0]*(*it)[0]+(*it)[1]*(*it)[1]+(*it)[2]*(*it)[2];
					if(len2>max) max=len2;
					it++;
				}
数组迭代器NAryMatIterator
cv::MatIterator<>将不连续内存区域打包以同时处理多个数组。还有另一种形式的迭代器
cv::NAryMatIterator<>它只要求被迭代的数组有相同的几何结构，即维度以及每一个维度的范围。
该迭代器不会返回一个用于迭代的单独元素，而是通过一堆数组来进行N-ary迭代器操作，这些返回的数组被称为
"面"plane。**一个面表示输入数组有连续内存的部分**，一般来说是一维或二维的片段(面的维度不限于二维，只要
它所占的内存区域是连续分布的，它可以更大)。这也是如何处理非连续内存的方法:可以一个接一个处理其中连
续的内存片段，对于每一个面，你既可以通过数组操作进行处理，也可以通过自己的方式进行正常的迭代。
("正常的"表示不需要检查该区域内存是否连续)
面所包含的内容都是从被迭代的多维数组的内容中分离出来的。
例4-1:按面将一个多维数组相加

				const int n_mat_size = 5;
				const int n_mat_sz[] = {n_mat_size, n_mat_size, n_mat_size};
				cv::Mat n_mat(3,n_mat_sz, CV32FC1); //3通道5x5x5
				//用随机数填充
				cv::RNG rng;
				rng.fill(n_mat, cv::RNG::UNIFORM, 0.f, 1.f);

				const cv::Mat* arrays[] = {&n_mat, 0};
				cv::Mat my_planes[1];
				cv::NAryMatIterator it(arrays, my_planes);
这里，有了N-ary迭代器。我么要计算m0和m1的和，并将结果放在m2中。

				float s = 0.f;//所有面上的总和
				int n = 0; // 面的总数
				for (int p = 0; p<it.nplanes; p++, ++it)
				{
					s += cv::sum(it.planes[0])[0];
					n++;
				}
在本例中，我们首先创建了一个三维数组n_mat并使用125个大小介于0到1的随机数填充该数组。为了初始化
cv::NAryMat迭代器对象，我们需要准备两件事，第一，我们需要指向包含指向所有我们想要迭代的cv::Mat
的C风格指针数组，这个数组必须以0或NULL终止;第二，我们需要另一个可以作为面的参考的C风格的cv::Mat
数组，从而可以通过它们进行迭代(这里，数组的长度为1)。
我们创建了N-ary迭代器之后，就可以通过它迭代。这种迭代是基于我们给迭代器的数组的面进行迭代的。面
的数量始终由`it.nplanes`决定。N-ary迭代器包含有planes的C风格数组，它为每个输入数组保存当前面的头。
在本例中，只有一个数组被迭代，所以我们只需要引用it.planes[0]，在这里面只有一个且只含有一个数组。
然后对每一个面调用cv::sum()并得到最终结果。
例4-2:使用N-ary将两个数组相加

				const int n_mat_size = 5;
				const int n_mat_sz[] = { n_mat_size, n_mat_size, n_mat_size };
				cv::Mat n_mat0(3, n_mat_sz, CV32FC1);
				cv::Mat n_mat1(3, n_mat_sz, CV32FC1);

				cv::RNG rng;
				rng.fill(n_mat0, CV::RNG::UNIFORM, 0.f, 1.f);
				rng.fill(n_mat1, CV::RNG::UNIFORM, 0.f, 1.f);

				const cv::Mat* arrays[] = { &n_mat0, &n_mat1, 0 };
				cv::Mat my_planes[2];
				cv::NAryMatIterator it(arrays, my_planes);

				float s = 0.f;
				int n = 0;
				for (int p = 0; p < it.nplanes; p++, ++it)
				{
					s += cv::sum(it.planes[0])[0];
					s += cv::sum(it.planes[1])[0];
					n++;
				}
在第二个例子中，arrays的C风格的数组被每个输入序列赋予一个指针，my_planes提供了两个矩阵。当在面上
迭代时，对于每一步来说，planes[0]包含来自n_mat0的一个面，planes[1]包含来自n_mat1的一个面。然后
将两个面相加并添加到累加器中。
it有一个成员it.size，它指明每个面的大小，这个变量显示了面中元素的数量，所以它不会包含通道数这一要素。
在之前的例子中，如果it.planes是4，it.size将会是16(**为什么??????**)

				///////////////////////compute dst[*] = pow(src1[*],src2[*])/////////
				const Mat* arrays[] = { src1, src2, dst, 0 };
				float* ptrs[3];

				cv::NAryMatIterator it(arrays, (uchar**)ptrs);
				for (size_t i = 0; i < it.nplanes; i++, ++it) //面的数量
				{
					for (size_t j = 0; j < it.size; j++)  //面的大小
					{
						ptr[2][j] = std::pow(ptrs[0][j], ptrs[1][j]);
					}
				}
				








