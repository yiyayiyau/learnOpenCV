# 图像处理
在图像结构体上根据图像像素之间的联系对之进行高级处理。

## 预备知识

### 滤波、核、卷积
滤波器指的是一种有一幅图像I(x,y)根据像素点x,y附近的区域计算得到的一幅新图像I´(x,y)的算法。
其中，模板规定了滤波器的形状以及这个区域内像素的值的组成规律。滤波器也成为核(同一个意思，
信号处理领域通常使用滤波，数学领域通常使用核)。线性核代表I´(x,y)的值由I(x,y)及其周围的像
素的值加权相加得到。基于这种线性核的滤波就是卷积。

### 锚点
定义了核与源图像的对齐关系。

### 边界外推和边界处理
在源图像的周围添加虚拟像素。cv::blur()函数实现了对图像每个像素与周围像素的均值操作。为了
处理缺少相邻像素点的边缘像素，一般通过自定义的方式在场景中处理该问题。

#### 自定义边框
cv::copyMakeBorder()为图像创建边框。只需指明填充方法。
* cv::BORDER_CONSTANT	复制常量
* cv::BORDER_WARP		复制对边
* cv::BORDER_REPLICATE	复制边缘的像素
* cv::BORDER_REFLECT	镜像复制
* cv::BORDER_REFLECT_101除边界像素外，镜像复制

#### 自定义外推
cv::borderInterpolate()计算外推像素的原位置。

## 阙值化操作
cv::threshold() 用一个1x1的核进行卷积。
例子10.1

## Otsu算法
自动决定cv::threshold()最优的阙值。该算法遍历所有可能的阙值， 然后对每个阙值结果的两类图
像计算方差。该算法并不相对高效。

## 自适应阙值
cv::adaptiveThreshold()，这种方法中的阙值在卷积的过程中自动变化。逐像素计算自适应阙值。该
方法计算每个像素周围bxb区域的加权平均-常数C。权重可以是相等的也可以是高斯方程计算得出的。
对于一般的阙值化操作，当图像中出现较大的明暗差异时，自适应阙值时非常有效。这个函数仅处理
单通道8位或浮点型图像。

## 平滑
亦称"模糊"，目的减少噪声和伪影等。
### 简单模糊和方框型滤波器cv::boxFilter()
cv::blur() 实现了简单模糊
方框型滤波器: 矩形，值相等。若值位1/面积A，则称为"归一化方框型滤波器"。blur是boxFilter的
一种特殊形式。
### 中值滤波器 Median Filter
cv::medianBlur() 取邻域内的中值。对有较大孤立的异常值(比如数字影像中的拍摄噪声)非常敏感。
少量具有较大偏差的点也会严重影响到**均值**滤波，而中值滤波可以用中间值来消除异常值。
非线性核
### 高斯滤波器
cv::GaussianBlur() 最常用。3x3,5x5,7x7的核相对其他核有性能优化。支持单/三通道的8/32位
浮点型图像。高斯模糊的过程减缓像素在空间上的变化，因此与邻域的关系紧密，然而随机噪声在像素
间的变化幅度很大，不与空间相关。所以高斯平滑很好地减弱了噪声同时保留了小信号，但却破坏了边缘
信息。也就是高斯模糊把边缘也模糊了。
### 双边滤波cv::bilateralFilter()
对每个像素及其邻域内的像素进行加权平均，其权重由两部分组成，第一部分同高斯平滑，第二部分是
高斯权重，不过它是基于色彩强度差计算而来的。在多通道图像上强度差由各分量的加权累加代替。
双边滤波可以看作是一种高斯滤波，只是相似程度更高的像素权值更高，边缘更明显，对比度更高。
双边滤波的效果就是把源图像变成一幅水彩画，在多次迭代后更明显。该方法在**图像分割**领域
十分有用。
参数中滤波器的大小d对算法的效率影响很大，通常处理视频时不大于5。非实时应用可达9。sigmaColor
越大，平滑时包括的色彩强度越大，图像的不连续性更明显。sigmaspace的值比如10也会有明显的效果，
150会很大影响，有卡通的效果。

## 导数和梯度
### 索贝尔导数 Sobel算子
Sobel算子可实现任意阶导数和混合偏导数。实际上是一种拟合。可以快速迭代式的构造各种大小的核。
大的核可以更好的近似导数，但是如果导数在空间上变化剧烈，核太大会导致结果发生偏差。
缺点在核比较小时准确度不高，而大型的核使用了较多的点导致精度问题不显著。
在使用上，如果src是一个8位图像，dst至少是CV_16S的深度才能保证不会出现溢出。可以在单方向上
求导(滤波)。
### Scharr 滤波器
对于3x3的Sobel滤波器，梯度角距离水平或垂直方向越远，误差越明显。调用Sobel时将ksite设置为
cv::SCHARR可消除3x3
这样小但很快的Sobel导数滤波器带来的误差。Scharr滤波器精度更高。
### 拉普拉斯变换
Laplacian算子可以通过二阶导数定义，因此可以将它的离散实现与二阶Sobel导数联系起来。
Laplacian算子可以用于各种场景处理，常见的应用是**匹配斑点**。Laplacian算子就是图像在x，y轴
方向上的导数之和，意味着一个被较大值包围的点或小斑点(比ksize小)处的值将变得很大。而被较小值
包围的点或小斑点处的值将在负方向上变得很大。
Laplacian算子也可以用于边缘检测: 一个函数的一阶导数在原函数变化大的地方，值会相应变大。同样，
在边缘处，一阶导数将很大。我们可以在二阶导为0的地方搜寻这样的一个极大值，源图像中的边缘通过
Laplacian算子运算后会变成0。然而，真正的边缘和一些不是边缘的地方在Laplacian图像中都会变成0。
不过通过滤掉Sobel一阶导数中拥有较大值的点可以解决这个问题。
### 图像形态学 
#### 膨胀和腐蚀
应用: 消除噪声，元素分割和连接，定位强度峰值或孔洞，图像梯度。
膨胀是使非零像素生长，而腐蚀则相反。膨胀扩张明亮区域，腐蚀缩短明亮区域。膨胀填充凹面，腐蚀消
除突起。cv::erode(),cv::dilate()
#### 通用形态学函数
处理对象是二值图像时，基本的腐蚀和膨胀操作就够了。处理灰度图或彩色图像时，使用
cv::morphologyEx()
* cv::MOP_OPEN, 开操作，即先腐蚀再膨胀。消除大于邻域点的孤立异常值。细微的明亮区域被消除，
	其余明亮区域被孤立，但大小保持不变。
* cv::MOP_CLOSE，闭操作，先膨胀再腐蚀。消除小于邻域点的孤立异常值。明亮区域被连通同时保持
	基本大小。
* cv::MOP_GRADIENT，形态学梯度。膨胀-腐蚀。产生边缘。高亮灰度图中的剧烈变化的部分。
* cv::MOP_TOPHAT，顶帽操作。显示与邻域相比更亮的部分。源图像-开操作后的图像。提取明亮的局
	部凸起
* cv::MOP_BLACKHAT，黑帽操作 。显示与邻域相比更暗的部分。闭操作后的图像-源图像。提取暗洞。
#### 自定义核
cv::getStructuringElement()
* cv::MORPH_RECT 矩形
* cv::MORPH_ELLIPSE 椭圆形
* cv::MORPH_CROSS 交叉
## 用任意线性滤波器做卷积
分解卷积核可以提高卷积计算的效率。一个可分核可以理解成两个一维核，在卷积时先调用x内核，再调
用y内核。
## 用 cv::filter2D()卷积
对图像进行卷积。如果定义了锚点，核的大小可以为偶数，否则必须是奇数。
## 通过cv::sepFilter2D使用可分核
cv::sepFilter2D()与cv::Filter2D()相似，只是它使用小核，rowkernel和columnKernel,n_1x1,
1xn_2, n_1 和 n_2 可以不相等。
## 生成卷积核
cv::getDerivKernel()用于生成Sobel核和Scharr核，即导数核。而cv::getGaussianKernel()生
成高斯核。导数核是可以分解的。导数核永远是正方形的，可以分解为1xksize 和 ksizex1的向量。
ksize可以是1,3,5,7,或cv::SCHARR。高斯核也是可分的。高斯核计算一个 ksizex1的数组作为结果，
ksize 是一个奇数，sigma是标准差。

练习:

