# OpenCV的数据类型
## 从C++继承的基础数据类型, int, float,点,矩形,大小
* 固定向量类,容器类,cv::Vec<>模板 cv::Vec{2,3,4,6}{b,w,s,i,f,d},cv::Vec4d, 2,3,4,6个元素; 
  b=unsigned char无符号字符; w=unsigned short; s=short短整型; i=int是32位整型; f=float是32位浮点数; d=double是64位浮点数
  固定向量类继承自固定矩阵类。
  cv::Scalar继承自固定向量类
  其他类的重要操作依赖于转换成固定向量类。
* 固定矩阵类,cv::Matx<> cv::Matx{1,2,3,4,5,6}{1,2,3,4,5,6}{f,d}
  编译时就已知维度，所以叫固定（大小）矩阵类。它们内部的数据都分配在堆栈上，所以分配和清除都很快。
  固定矩阵类是一个模板cv::Matx<>, 独立的矩阵通常通过别名分配。
  cv::Matx支持的操作:
  默认构造函数 cv::Matx33f m33f; cv::Matx43d m43d;
  复制构造函数: cv::Matx22d m22d(n22d); 
  值构造函数: cv::Matx21ff m(x0,x1); cv::Matx44d m(x0,x1,x2,x3,...,x15);
  含相同元素的矩阵: m33f = cv::Matx33f::all(x);
  全零矩阵: m23d = cv::Matx23d::zeros();
  全一矩阵: m16f = cv::Matx16f::ones();
  单位矩阵: m33f = cv::Matx33f::eye();
  创建一个可以容纳另一个矩阵对角线的矩阵: m31f = cv::Matx31f::diag();
  创建一个均匀分布的矩阵: m33f = cv::Matx33f::randu(min,max);
  创建一个正太分布的矩阵: m33f = cv::Matx33f::nrandn(mean, variance);
  成员访问: m(i,j), m(i); //1个arg仅适用于1-Dim Matrix
  矩阵代数运算: m1 = m0; m0*m1; m0+m1; m0-m1;
  单例代数: m*a; a*m; m/a;
  比较: m1 == m2; m1 != m2;
  点积: m1.dot(m2); m1.ddot(m2);//区别在于精度?
  改变矩阵形状: m91f = m33f.reshape<9,1>();
  变换操作符: m44f = (Matx44f) m44d
  提取(i,j)处的子矩阵: m44f.get_minor<2,2>(i,j);
  提取第i行: m14f = m44f.row(i);
  提取第j列: m41f = m44f.col(j);
  提取矩阵对角线: m41f = m44f.diag();
  计算转置: n44f = m44f.t();
  逆矩阵: n44f = m44f.inv(method);//默认方法是cv::DECOMP_LU
  解线性系统: m31f = m33f.solve(rhs31f, method); m32f = m33f.solve<2>(rhs32f, method);
    //默认方法是cv::DECOMP_LU
  元素点乘: m1.mul(m2);
* cv::Point类,cv::Point{2,3}{i,f,d}, cv::Point2i, 其成员可以通过名称变量(mypoint.x, mypoint.y等)而不是通过下标访问(myvec[0], myvec[1]等)
  Point类支持的操作:
  默认构造函数 cv::Point2i p; cv::Point3i p;
  复制构造函数: cv::Point3f p2(p1); 
  值构造函数: cv::Point2i(x0,x1); cv::Point3d p(x0,x1,x2);
  成员访问: p.x; p.y; p.z;
  点乘: float x=p1.dot(p2); double x=p1.dot(p2);
  叉乘: p1.cross(p2);仅适用于3维点类
  判断一个点是否在矩形r内: p.inside(r);仅适用于2维点类
* cv::Scalar本质是一个4维Point类,cv::Scalar继承自cv::Vec<double,4>,cv::Scalar是双精度四元素向量的别名,通过整数下标访问
  Scalar类支持的操作:
  默认构造函数 cv::Scalar s;
  复制构造函数: cv::Scalar s2(s1); 
  值构造函数: cv::Scalar s(x0); cv::Scalar s(x0,x1,x2,x3);
  元素相乘s1.mul(s2);
  四元数共轭s.conj();//(returns cv::Scalar(s0,-s1,-s2,-s3))
  四元数真值测试s.isReal();//(returns true, if s1==s2==s3==0)
* cv::Size 有width和height两个属性而不是x和y, cv::Size是cv::Size2i的别名,对于浮点类型的宽度和高度有cv::Size2f
  可以与Point类相互转换,主要区别在于成员函数Point对应的是x和y,Size对应的是width和height,cv::Size与 cv::Size2i 是等价的,都表示整数大小
  Size类支持的操作:
  默认构造函数 cv::Size sz; cv::Size2i sz; cv::Size2f sz;
  复制构造函数: cv::Size sz2(sz1); 
  值构造函数: cv::Size2f sz(w,h);
  成员访问: sz.width; sz.height;
  计算面积: sz.area();
Size类不可以转换成固定向量类
Point类可以转换成固定向量类
Point类和固定向量类可以转换成Size类
* cv::Rect 整数类型的矩形,包含Point和Size,非轴对称矩形cv::rotateRect 它包含有cv::Point2f类型的中心点和一个 cv::Size2f类型的Size,还有一个额外的浮点类型的角度
  矩形由左上角的点(Point类的成员x和y)和大小(Size类的成员width和height)来表示, 但它并不是从Point类或Size类继承过来的. Rect是用整数实例化的一个矩形模板的别名
  Rect类支持的操作:
  默认构造函数 cv::Rect r;
  复制构造函数: cv::Rect r2(r1);
  值构造函数: cv::Rect(x,y,w,h);
  由起始点和大小构造: cv::Rect(p,sz);
  由两个对角构造: cv::Rect(p1,p2);
  成员访问: r.x; r.y; r.width; r.height;
  计算面积: r.area();
  提取左上角: r.tl();
  提取右下角: r.br();
  判断点p是否在矩形r内: r.contains(p);
  矩形r1和矩形r2的交集: cv::Rect r3 = r1&r2; r1&=r2;
  同时包含矩形r1和矩形r2的最小面积矩形: cv::Rect r3 = r1|r2; r1|=r2;
  平移矩形r x个数量: cv::Rect rx = r+x; r+=x;
  扩大矩形r s大小: cv::Rect rs = r+s; r+=s;
  比较矩形r1与矩形r2是否相等: bool eq = (r1==r2);
  比较矩形r1与矩形r2是否不相等: bool eq = (r1!=r2);
* cv::RotatedRect类
  是一个包含中心点cv::Point2f,一个大小cv::Size2f和一个额外的角度float的容器。
  cv::RotatedRect以中心点为原点，而cv::Rect以左上角为原点。
  cv::RotatedRect类支持的操作:
  默认构造函数 cv::RotatedRect rr();
  复制构造函数: cv::RotatedRect rr2(rr1);
  值构造函数: cv::RotatedRect(p,sz，theta);
  由两个点构造: cv::RotatedRect(p1,p2);
  成员访问: rr.center, rr.size, rr.angle;
  返回四个角的列表: rr.points(pts[4]);
  返回最小外接矩形: cv::Rect brect = rr.boundingRect();

## 辅助对象, 垃圾收集指针,用于数据切片的范围对象,抽象的终止条件类
## 大型数组类型,Mat,稀疏矩阵SparseMat
## STL 标准模板库
