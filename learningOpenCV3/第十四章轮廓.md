# 轮廓
## 轮廓查找
* findContours()从二维图像中计算轮廓。它可以处理从cv::Canny()或cv::threshold(),
cv::adaptiveThreshold()得到的图像。
* 输入图像必须是8位单通道图像，而且是被转化为二值的图像。
* 输入会被涂改，(如果将来还有用)应该复制之后再传给findContours()
* 在轮廓vector中， contours[i]是一条特定轮廓，contours[i][j]是contours[i]的一个点。
* hierarchy是可选项，输出轮廓的树结构。
* 轮廓的提取方式mode:
	* cv::RETR_EXTERNAL, 只检索最外层轮廓
	* cv::RETR_LIST, 所有轮廓保存在一个list中。一般不建议使用
	* cv::RETR_CCOMP, 双层结构，顶层是所有外部边界，其次是孔的边界。
	* cv::RETR_TREE, 检索所有轮廓并建立网(树)状结构。
* 轮廓如何被表示method:
	* cv::CHAIN_APPROX_NONE, 将所有的点都保存，每个点都成为前一个点的8个临点之一。
	* cv::CHAIN_APPROX_SIMPLE，压缩水平，垂直，斜的部分，只保留最后一个点。例如矩形只需返
		回4个点
	* cv::CHAIN_APPROX_TC89_L1 / cv::CHAIN_APPROX_TC89_KCOS，使用Teh-Chai链逼近算法中
		的一个。该算法是一种更复杂且计算密集型的算法，用于减少返回的点数。
* 偏移offset。在如下情况中非常有用: 1.希望从ROI中提取的轮廓用原图坐标系表达，2.希望提取出
	的轮廓用子区域坐标系表达

###表示轮廓的方式
* 用一系列二维顶点来表示, vector<cv::Point> vector<cv::Point2f>;
* 将每个点表示为相对起始点在特定方向上发生的位移，例如Freeman chain方法。

## 绘制轮廓
* cv::drawContours()
* contourIdx告诉函数需要绘制的是某一条轮廓还是全部轮廓。<0:全部轮廓 >=0:绘制该条轮廓 
* color是一个四元组cv::Scalar
* thickness，整数，表示线的粗细
* lineType可以是4或8，代表绘制的线将是四联通(不美观)或八连通(美观)或是cv::AA线(美观)。
* maxLevel, 和 hierarchy共同起作用。将限制绘制的层次深度。maxLevel=0 表示只绘制最高层。
	对轮廓树很有用。或者用于cv::RETR_CCOMP的只显示最外层。
* offset，可以画在另外的地方。当轮廓坐标系被转换成质心坐标系或其他局部坐标系时，该参数非常
	有用。
* 请看代码示例14.2
 
## 快速连通区域分析
* 区分出是否是同一区域。在背景分割算法中，该分析常常被用作后处理滤波器，用于去掉小噪声块。在
	OCR这种含有已知前景待提取的问题中也有其用武之地。
* OpenCV的连通区域分析算法要求输入是一张二值图像，输出的是一张像素标记图。同一区域的非零像
	素值都是一样的。
* 调用findContours()(使用cv::RETR_CCOMP),然后循环调用drawContours()(使用color=
	component_label, thickness=-1)--> 速度慢, 原因:
	* cv::findContours()首先为每条轮廓分配一个独立的标准模板库向量(vector)，而图像中可能
		存在成百上千条轮廓
	* 想填充一块一条由一条或多条轮廓包围的非凸区域时，cv::drawContours()也很慢，而且还要
		收集所有包围该区域的小线段并排序
	* 收集一块连通区域的基本信息需要更多更耗时的函数调用。
* cv::connectedComponents() cv::connectedComponentsWithStats() 更好。前者简单生成了
	标记图，后者还包含一些重要信息，比如包围框，面积，质心等等。如果不需要质心信息，则输入
	cv::noArray()。它们直接实现了 " Two Strategies to Speed up Connected Component 
	Labeling Algorithms"论文中的高效算法。
* 例子14.3

## 轮廓分析

### 多边形逼近
* cv::approxPolyDP() 
	DP算法:思想是先在轮廓中找到最远的两个点相连(直线)，然后再找一个离线段最远的点(形成三
	角形的逼近轮廓)，依次递推。
	函数中的精度epsilon即指某一个点到逼近的轮廓的距离。

### 几何特性

#### 长度/弧长
cv::arcLength()提取输入轮廓的长度。输入可以是点向量或二通道数组。是否闭合，如果闭合，最后
一个点到第一个点的距离也会算入其中。
#### 矩形包围框
cv::boundingRect() 外包围矩形对任何点集都适用。返回一个cv::Rect类型, 该矩形四边水平和垂直
#### 最小矩形框
cv::minAreaRect() 可以是倾斜的。类似cv::RotatedRect
#### 最小包围圆
cv::minEnclosingCircle() 
#### 椭圆边框
cv::fitEllipse()该椭圆边框与轮廓最相似，但并不是所有点都在椭圆内部。由最小二乘拟合方法算出。
返回一个cv::RotatedRect该矩形正好完全包围椭圆。
#### 最佳拟合线
cv::fitLine()既可以处理二维点也可以处理三维点。输出可以是cv::Vec4f(2维直线)或cv::Vec6f
(3维直线)
#### 轮廓的凸包
cv::convexHull()用凸包简化轮廓。检测一个点是否落在凸多边形内的过程很快。检测一个点是否在轮
廓内可以预先检测是否在凸包内。
返回可以是一组点，也可以是一组整数，该整数对应输入的点的索引。如果输入的点是标准模板库向量对
象(vector<cv::Point>)则参数returnPoints可以忽略。如果输入的点是Mat类型的数组，那么需要返
回点时，该参数须设为true，要返回索引时，该参数为false。

### 几何学测试
* 判断一个点是否在矩形内 cv::Rect中的contains()方法
* 包含两个矩形的最小矩形框 OR操作, 或 rect1 | rect2
* 计算重叠部分 AND操作，或 rect1 & rect2
对于一般的曲线操作(保括RotatedRect)，可以使用库函数。
#### 点是否在多边形内
cv::pointPolygonTest() 多边形用contour数组表示。既可以是标准模板向量，也可以是nx1的二通道
点数组。
* measureDist 为true, 若在轮廓内，距离为0，否则返回该点距离最近的轮廓边缘的距离。
* measureDist 为false，返回 +1(内部), -1(外部) , 0(在轮廓上)
#### 轮廓是否为凸
cv::isContourConvex() 很多算法只能用于凸多边形，或在凸多边形使用时可以大大简化。假定输入的
轮廓是多边形，即不能出现自相交。

	
## 匹配轮廓与图像
匹配多条轮廓(比较两条计算好的轮廓，或比较一条轮廓和一个抽象模板)

### 矩 moment
cv::moments()

轮廓矩代表一条轮廓，一幅图像，一个点集的一些高级特则会那个。
m_00, 中的参数0，0代表矩的数值定义中的下标。如果图像为二值图，m_00表示图像上所有值非零的区域。
当处理轮廓时，代表轮廓的长度(一说面积)。当处理点集时，代表点的数量。对同一张二值图，将m_10和
m_01相加再除以m_00,能得到整个对象的平均x值和y值。

Moments包含:
* m00,						0阶矩 (=0阶中心矩)
* m10,m01,					1阶矩 
* m20,m11,m02,				2阶矩
* m30,m21,m12,m03,			3阶矩
* mu20,mu11,mu02,			2阶中心矩(1阶中心矩mu10=mu01=0)
* mu30,mu21,mu12,mu03		3阶中心矩
* nu20,nu11,nu02,			2阶Hu不变矩(nu00=1,nu10=nu01=0)
* nu30,nu21,nu12,nu03,		3阶Hu不变矩

#### 中心矩的位移不变性
给定一条轮廓或一幅图像，不管轮廓出现在图像中的哪个地方，m_00矩都是相同的，高阶矩则会改变。而
中心矩是相对物体质心测量得到的(通过减去均值实现)，所以不随物体在图像中的绝对位置的改变而改变。
中心距用于比较图像中不同位置的两个物体。
#### 归一化中心距的缩放不变性
比较图像中两个除了尺度大小其他全部相同的物体用归一化中心矩。(通过除以物体的总尺寸实现)
#### Hu不变矩的旋转不变性
Hu不变矩是归一化中心距的线性组合。通过组合不同的归一化中心距得到一个反应图像不同特征的不变函
数，这个函数不随着尺度、旋转、镜面映射(除了h1)的变化而变化。
cv::HuMoments() 输入为cv::moments()函数返回的cv::Moments对象。

### 使用Hu矩进行匹配
cv::matchShapes()
输入可以是灰度图也可以是轮廓。
匹配方法(引用Hu矩经进行计算):
* cv::CONTOURS_MATCH_I1
* cv::CONTOURS_MATCH_I2
* cv::CONTOURS_MATCH_I3

## 利用形状场景方法比较轮廓 shape ontext
### 形状模块的结构
形状距离提取器cv::ShapeDistanceExtractor
cv::ShapeContextDistanceExtractor方法在函数实现中采用了形状变换和直方图代价提取函数。

cv::ShapeTransformer
直方图代价提取算子cv::HistogramCostExtractor派生的代价提取器:
* cv::NormHistogramCostExtractor
* cv::ChiHistogramCostExtractor
* cv::EMDHistogramCostExtractor
* cv::EMDL1HistogramCostExtractor
薄板样条变化器 cv::ThinPlateSplineShapeTransformer 解决了移动金属薄板上的一些控制点到
不同位置时产生的映射问题。随着控制点的变化，金属薄板随之发生形变，由此产生的稠密映射就是算法
得到的变换式。

### Hausdorff距离提取算子
可以用工厂方法cv::createHausdorffDistanceExtractor()创建，cv::computeDistance()

## 总结
轮廓在表达图像的空间划分或分割时很有用。OpenCV库提供了用于比较不同空间、测试空间性质的工具，
比如凸、矩、轮廓与点之间的关系等。还提供了许多方法用于匹配轮廓和形状。还包括用于匹配的特征，
既有经典特征也有基于形状距离提取算子接口的特征。
## 练习 非标准答案，自己作答
1. 在一条含有N个点的封闭轮廓中，我们可以通过比较每个点与其他点的距离，找出最外层的点。
这样一个算法的复杂度是多少，如何用更快的速度完成这个任务
答: 1+2+3+...+(N-1) = N*(N-1)*0.5; findContour RETR_EXTERNEL 方法
2. 一张4x4的图像中能包含的最大闭合轮廓有多大，轮廓面积是多少
答: 4+3+3+2个pixel组成的最外层轮廓。面接为16
3. 不使用cv::isCountourConvex()函数，描述一个可以用来判断一条闭合轮廓是否为凸轮廓的算法。
答: 用convexHull找到该轮廓的凸包，比较面积。猜测结果应该不太准。
4. 描述用于下面任务的算法:
* 判断一个点是否在一条直线上
* 判断一个点是否在一个三角形内
* 不使用cv::pointPolygonTest()，判断一个点是否在一个多边形内。
5. 在黑色背景长画一个半径位20的白色的圆，周长是20*pi=125.7,保存。
* 读入该图像，转化为灰度图，阙值化，寻找轮廓。轮廓的长度是多少，是否与计算的相同
* 将125.7作为轮廓的基长度，分别用基长度的90%,66%,33%,10%作为参数运行approxPolyDP()函数，
	寻找轮廓长度，并画出结果。
6. 假设我们正在开发一个瓶子检测算子，希望能创造一个"瓶子"特征。我们有很多瓶子的图像，在这些
图像上进行分割和轮廓寻找都很容易，但图中瓶子都是旋转过的，且大小不一。我们可以画出轮廓，找到
Hu矩，以获得一个不变的瓶子特征向量。至此一切顺利，但我们是画出填充的轮廓还是之画出轮廓线即可
?解释你的答案。
答: 只画出轮廓线即可。
7. 在第6题使用moments()提取瓶子轮廓矩时，我们应该如何设置isBinary标志位?解释你的答案
8. 使用在讨论Hu矩时用到的字母形状。通过对这些形状进行不同角度的旋转和尺度缩放，或二者组合，
得到不同的图像。描述哪些Hu特征对应旋转、哪些特征对应缩放、哪些二者都对应
9. 在google图像中搜索ArUco markers 选择较大的一些图像(有点像二维码)
* 矩适用于寻找ArUco图像吗
* 矩或Hu特征适用于读取ArUco码吗
* matchShapes()适用于读取该码吗
10. 创造一个形状并保存。进行缩放、旋转、旋转缩放并存储。用matchShapes()比较它们
11. 修改形状场景例子或修改OpenCV3中的shape_example.cpp例子，用Hausdorff距离代替形状场景
度量
12. 获得五张含有不同手势的图像，在拍照时，穿上黑色外套或彩色手套，以便选择算法能够找到手的轮
廓。
* 尝试用matchShapes()识别手势
* 尝试用computeDistance()识别手势
* 哪个方法更好，为什么
