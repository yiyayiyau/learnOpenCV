# 轮廓
## 轮廓查找
* findContours()从二维图像中计算轮廓。它可以处理从cv::Canny()或cv::threshold(),
cv::adaptiveThreshold()得到的图像。
* 输入图像必须是8位单通道图像，而且是被转化为二值的图像。
* 输入会被涂改，(如果将来还有用)应该复制之后再传给findContours()
* 在轮廓vector中， contours[i]是一条特定轮廓，contours[i][j]是contours[i]的一个点。
* hierarchy是可选项，输出轮廓的树结构。
* 轮廓的提取方式mode:
	* cv::RETR_EXTERNAL, 只检索最外层轮廓
	* cv::RETR_LIST, 所有轮廓保存在一个list中。一般不建议使用
	* cv::RETR_CCOMP, 双层结构，顶层是所有外部边界，其次是孔的边界。
	* cv::RETR_TREE, 检索所有轮廓并建立网(树)状结构。
* 轮廓如何被表示method:
	* cv::CHAIN_APPROX_NONE, 将所有的点都保存，每个点都成为前一个点的8个临点之一。
	* cv::CHAIN_APPROX_SIMPLE，压缩水平，垂直，斜的部分，只保留最后一个点。例如矩形只需返
		回4个点
	* cv::CHAIN_APPROX_TC89_L1 / cv::CHAIN_APPROX_TC89_KCOS，使用Teh-Chai链逼近算法中
		的一个。该算法是一种更复杂且计算密集型的算法，用于减少返回的点数。
* 偏移offset。在如下情况中非常有用: 1.希望从ROI中提取的轮廓用原图坐标系表达，2.希望提取出
	的轮廓用子区域坐标系表达

###表示轮廓的方式
* 用一系列二维顶点来表示, vector<cv::Point> vector<cv::Point2f>;
* 将每个点表示为相对起始点在特定方向上发生的位移，例如Freeman chain方法。

## 绘制轮廓
* cv::drawContours()
* contourIdx告诉函数需要绘制的是某一条轮廓还是全部轮廓。<0:全部轮廓 >=0:绘制该条轮廓 
* color是一个四元组cv::Scalar
* thickness，整数，表示线的粗细
* lineType可以是4或8，代表绘制的线将是四联通(不美观)或八连通(美观)或是cv::AA线(美观)。
* maxLevel, 和 hierarchy共同起作用。将限制绘制的层次深度。maxLevel=0 表示只绘制最高层。
	对轮廓树很有用。或者用于cv::RETR_CCOMP的只显示最外层。
* offset，可以画在另外的地方。当轮廓坐标系被转换成质心坐标系或其他局部坐标系时，该参数非常
	有用。
* 请看代码示例14.2
 
## 快速连通区域分析
* 区分出是否是同一区域。在背景分割算法中，该分析常常被用作后处理滤波器，用于去掉小噪声块。在
	OCR这种含有已知前景待提取的问题中也有其用武之地。
* OpenCV的连通区域分析算法要求输入是一张二值图像，输出的是一张像素标记图。同一区域的非零像
	素值都是一样的。
* 调用findContours()(使用cv::RETR_CCOMP),然后循环调用drawContours()(使用color=
	component_label, thickness=-1)--> 速度慢, 原因:
	* cv::findContours()首先为每条轮廓分配一个独立的标准模板库向量(vector)，而图像中可能
		存在成百上千条轮廓
	* 想填充一块一条由一条或多条轮廓包围的非凸区域时，cv::drawContours()也很慢，而且还要
		收集所有包围该区域的小线段并排序
	* 收集一块连通区域的基本信息需要更多更耗时的函数调用。
* cv::connectedComponents() cv::connectedComponentsWithStats() 更好。前者简单生成了
	标记图，后者还包含一些重要信息，比如包围框，面积，质心等等。如果不需要质心信息，则输入
	cv::noArray()。它们直接实现了 " Two Strategies to Speed up Connected Component 
	Labeling Algorithms"论文中的高效算法。
* 例子14.3

## 轮廓分析

### 多边形逼近
* cv::approxPolyDP() 
	DP算法:思想是先在轮廓中找到最远的两个点相连(直线)，然后再找一个离线段最远的点(形成三
	角形的逼近轮廓)，依次递推。
	函数中的精度epsilon即指某一个点到逼近的轮廓的距离。

### 几何特性

#### 长度/弧长
cv::arcLength()提取输入轮廓的长度。输入可以是点向量或二通道数组。是否闭合，如果闭合，最后
一个点到第一个点的距离也会算入其中。
#### 矩形包围框
cv::boundingRect() 外包围矩形对任何点集都适用。返回一个cv::Rect类型, 该矩形四边水平和垂直
#### 最小矩形框
cv::minAreaRect() 可以是倾斜的。类似cv::RotatedRect
#### 最小包围圆
cv::minEnclosingCircle() 
#### 椭圆边框
cv::fitEllipse()该椭圆边框与轮廓最相似，但并不是所有点都在椭圆内部。由最小二乘拟合方法算出。
返回一个cv::RotatedRect该矩形正好完全包围椭圆。
#### 最佳拟合线
cv::fitLine()既可以处理二维点也可以处理三维点。输出可以是cv::Vec4f(2维直线)或cv::Vec6f
(3维直线)
#### 轮廓的凸包
cv::convexHull()用凸包简化轮廓。检测一个点是否落在凸多边形内的过程很快。检测一个点是否在轮
廓内可以预先检测是否在凸包内。
返回可以是一组点，也可以是一组整数，该整数对应输入的点的索引。如果输入的点是标准模板库向量对
象(vector<cv::Point>)则参数returnPoints可以忽略。如果输入的点是Mat类型的数组，那么需要返
回点时，该参数须设为true，要返回索引时，该参数为false。

### 几何学测试
* 判断一个点是否在矩形内 cv::Rect中的contains()方法
* 包含两个矩形的最小矩形框 OR操作, 或 rect1 | rect2
* 计算重叠部分 AND操作，或 rect1 & rect2
对于一般的曲线操作(保括RotatedRect)，可以使用库函数。
#### 点是否在多边形内
cv::pointPolygonTest() 多边形用contour数组表示。既可以是标准模板向量，也可以是nx1的二通道
点数组。
* measureDist 为true, 若在轮廓内，距离为0，否则返回该点距离最近的轮廓边缘的距离。
* measureDist 为false，返回 +1(内部), -1(外部) , 0(在轮廓上)
#### 轮廓是否为凸
cv::isContourConvex() 很多算法只能用于凸多边形，或在凸多边形使用时可以大大简化。假定输入的
轮廓是多边形，即不能出现自相交。

	
## 匹配轮廓与图像
匹配多条轮廓(比较两条计算好的轮廓，或比较一条轮廓和一个抽象模板)
### 矩 moment
轮廓矩代表一条轮廓，一幅图像，一个点集的一些高级特则会那个。
m_00, 中的参数0，0代表矩的数值定义中的下标。如果图像为二值图，m_00表示图像上所有值非零的区域。
当处理轮廓时，代表轮廓的长度。当处理点集时，代表点的数量。对同一张二值图，将m_10和m_01相加再
除以m_00,能得到整个对象的平均x值和y值。
